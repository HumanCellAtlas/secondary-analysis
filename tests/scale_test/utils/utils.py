import json
import uuid
import requests
import click


def compose_label(label_string):
    """Compose a valid label for Lira from a string of object.

    Args:
        label_string (str): A valid string of dictionary.

    Returns:
        dict: A valid dict that describes a Cromwell workflow label.

    """
    try:
        return json.loads(label_string)
    except (json.decoder.JSONDecodeError, TypeError):
        return None


def send_notification(lira_url, auth_token, notification):
    """Send a notification to a given Lira.

    Args:
        lira_url (str): A typical Lira url, e.g. https://pipelines.dev.data.humancellatlas.org/
        auth_token (str): The Lira auth_token.
        notification (dict): A dict of notification content.

    Returns:
        requests.Response: The response object returned by Lira.
    """
    response = requests.post(url=harmonize_url(lira_url) + 'notifications', json=notification, params={'auth': auth_token})
    return response


def load_es_query(es_query_path):
    """Load the ElasticSearch query json file.

    Args:
        es_query_path (str): The path to the ES query json file which is used for making subscription in BlueBox.

    Returns:
        dict: A dict of loaded es query content.
    """
    with open(es_query_path, 'r') as query_file:
        query_obj = json.load(query_file)
    return query_obj


def prepare_notification(bundle_uuid, bundle_version, es_query_path, subscription_id, label=None, transaction_id=None):
    """Compose the notification content from given values.

    Args:
        bundle_uuid (str): A Blue Box bundle uuid.
        bundle_version (str): A Blue Box bundle version.
        es_query_path (str): The path to the ES query json file which is used for making subscription in BlueBox.
        subscription_id (str): A valid Lira subscription id in Blue Box.
        label (str): A label to be added to the notification, which will then be added to the workflow started by Lira.
        transaction_id (str): A valid transaction id.

    Returns:
        dict: A dict of valid notification content.

    """
    notification = {
        'match': {
            'bundle_uuid': bundle_uuid,
            'bundle_version': bundle_version
        },
        'subscription_id': subscription_id,
        'transaction_id': transaction_id or _prepare_transaction_id(),
        'es_query': load_es_query(es_query_path)
    }
    if label:
        notification['labels'] = label
    return notification


def subscription_probe(lira_url, workflow_name='AdapterSmartSeq2SingleCell'):
    """A probe to fetch the subscription id.

    This function performs as a probe, fetches the subscription id by hitting the /version endpoint of Lira.

    Args:
        lira_url (str): A typical Lira url, e.g. https://pipelines.dev.data.humancellatlas.org/
        workflow_name (str): The workflow to be invoked by the script.

    Returns:
        str: A valid subscription id.
    """
    response = requests.get(harmonize_url(lira_url) + 'version')
    response.raise_for_status()
    subscription_id = response.json()['workflow_info'][workflow_name]['subscription_id']
    return subscription_id


def dump_metrics(path, **kwargs):
    """Dump metrics to a JSON file.

    This function dumps all of the given keyword metrics arguments to a JSON file.
    Args:
        path (str): The path to a file.
        **kwargs: Arbitrary keyword metrics arguments.
    """
    metrics = {name: value for name, value in kwargs.items()}
    with open(path, 'w') as metrics_file:
        json.dump(metrics, metrics_file)


def _prepare_transaction_id():
    """Transaction UUID generator.

    This function generates a fake valid UUID.

    Returns:
        str: A fake transaction UUID generated by standard uuid lib.
    """
    return str(uuid.uuid4())


def harmonize_url(url):
    """Harmonize the url string.

    This function checks if url ends with slash, if not, add a slash to the url string.
    Args:
        url (str): A string of url.

    Returns:
        str: A string of url ends with slash.
    """
    url = url.rstrip('/')
    return url + '/'


def read_bundles(bundle_list_file):
    """Read bundles in to a dict from a file.

    This function expects the JSON file follows a pre-defined schema:
        [
            {"bundle_uuid": XXX, "bundle_version": XXX},
            {"bundle_uuid": XXX, "bundle_version": XXX}
        ]

    Args:
        bundle_list_file (str): A path to the JSON file.

    Returns:
        dict: A dict of bundles listed in the file.
    """
    with open(bundle_list_file) as f:
        bundles = json.load(f)
    return bundles


def required_checker(ctx, **kwargs):
    """Check if all keyword arguments are provided by the user.

    This function checks if all of the given keyword arguments are given by the user, if not, stop all of the current
        commandline session. This custom checker function is better than the required=True flag of Click for this use
        case since it also shows the full help text of the click commands.

    Args:
        ctx (click.Context): The special internal object that holds state relevant for the script execution at
            every single level. This is automatically passed in by Click.
        **kwargs: Arbitrary keyword command arguments.
    """
    for name, val in kwargs.items():
        if not val:
            click.echo('Error: Missing option "--{}".'.format(name))
            click.echo(ctx.get_help())
            ctx.exit()


def auth_checker(ctx):
    """A probe to check the auth_token.

    This function performs as a probe, which validates the auth_token by sending a fake request to the Lira.

    Args:
        ctx (click.Context): The special internal object that holds state relevant for the script execution at
            every single level. This is automatically passed in by Click.

    Returns:
        str: The ensured valid Lira auth_token.

    """
    auth_token = click.prompt('Please enter a valid auth_token for Lira (inputs are hidden)', type=str, hide_input=True)
    probe_response = requests.post(ctx.obj['lira_url'] + 'notifications', params={'auth': auth_token}, json={'match': {}})
    if probe_response.status_code == 401:
        click.echo('Invalid auth token entered!')
        ctx.exit()
    else:
        return auth_token
